// main.cpp
#include <iostream>

int hello(int); // Объявление функции

int main() {
    std::cout << hello(5) << std::endl;
    return 0;
}
Файл f.cpp

cpp
Copy code
// f.cpp
int hello(int x) {
    return x + 1;
}
Компиляция обоих файлов

При компиляции main.cpp и f.cpp вместе ошибок не возникнет. Функция hello объявлена в main.cpp и определена в f.cpp. Компилятор связывает эти два файла, находит определение функции hello и компилирует без ошибок.
Компиляция только main.cpp

При попытке компилировать только main.cpp, вы получите ошибку линковщика, так как функция hello объявлена, но не определена в main.cpp. Компилятор не может найти определение hello, так как оно находится в другом файле, который не участвует в этой компиляции.
Добавление static в f.cpp

Если вы добавите модификатор static к определению функции hello в f.cpp, это означает, что функция hello будет видна только в пределах файла f.cpp. При попытке компилировать оба файла вместе, компилятор или линковщик выдаст ошибку, так как функция hello в main.cpp будет не найдена.
Копирование определения hello в main.cpp с модификатором static

После добавления одинакового определения функции hello с модификатором static и в main.cpp, и в f.cpp, оба файла можно успешно скомпилировать вместе. Теперь каждый файл имеет свою локальную копию функции hello, и они не конфликтуют друг с другом из-за модификатора static.
Количество копий функции hello в исполняемом файле

Если компилятор не оптимизирует неиспользуемые функции, то в финальном исполняемом файле будет две копии функции hello – по одной для каждого исходного файла (main.cpp и f.cpp). Каждая копия функции hello будет независима и видна только в пределах своего файла из-за модификатора static.




